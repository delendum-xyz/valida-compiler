//===-- DelendumInstructionSelector.cpp -----------------------------*- C++ -*-===//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// Delendum.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include <array>
#include <cstdint>

#include "DelendumRegisterBankInfo.h"
#include "DelendumSubtarget.h"
#include "DelendumTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/Support/Debug.h"

#define DEBUG_TYPE "delendum-isel"

using namespace llvm;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

namespace {

class DelendumInstructionSelector : public InstructionSelector {
public:
  DelendumInstructionSelector(const DelendumTargetMachine &TM, 
                              const DelendumSubtarget &STI,
                              const DelendumRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  static const char *getName() { return DEBUG_TYPE; }

  InstructionSelector::ComplexRendererFns selectAddr(MachineOperand &Root) const;

  // Custom instruction selection that didn't occur in TableGen
  bool customSelect(MachineInstr &I) const;
  bool selectConst(const APInt &Imm, MachineInstr &I) const;
  bool selectFrameIndex(MachineInstr &I) const;
  bool selectArithmetic(MachineInstr &I, int Offset) const;
  bool selectStore(MachineInstr &I) const;

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  int getOffsetFP(MachineOperand &MI) const;

  const DelendumTargetMachine &TM;
  const DelendumInstrInfo &TII;
  const DelendumRegisterInfo &TRI;
  const DelendumRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

DelendumInstructionSelector::DelendumInstructionSelector(
    const DelendumTargetMachine &TM, const DelendumSubtarget &STI,
    const DelendumRegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

int DelendumInstructionSelector::getOffsetFP(MachineOperand &MO) const {
  MachineInstr &I = *MO.getParent();
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineFrameInfo &MFI = MF.getFrameInfo();

  // FIXME: The stack pointer in MFI (SPOffset) is incorrect, so some
  // object offsets are returning zero. We have to manually calculate
  // those offsets until this is fixed.
  int Offset;
  int Index = MO.getIndex();

  // FIXME: How should we detect if an operand is going to be used
  // as a return value? It must stored in fp - 4 if so.
  if (MFI.isFixedObjectIndex(Index)) {
    Offset = -MFI.getObjectOffset(Index) - 8; // Relative to frame pointer
  } else {
    Offset = Index * 4; 
  }

  return Offset;
}

bool DelendumInstructionSelector::select(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");

  if (customSelect(I)) {
    I.removeFromParent();
    return true;
  }

  // Certain non-generic instructions also need some special handling.
  if (!isPreISelGenericOpcode(I.getOpcode()))
    return true;

  if (selectImpl(I, *CoverageInfo))
    return true;

  return false;
}

bool DelendumInstructionSelector::customSelect(MachineInstr &I) const {
  const unsigned Opcode = I.getOpcode();

  switch (Opcode) {
  case TargetOpcode::G_STORE:
    return selectStore(I);
  case TargetOpcode::G_CONSTANT:
  case TargetOpcode::G_FRAME_INDEX:
  case TargetOpcode::G_LOAD:
    return true;
  default:
    return false;
  }
}

bool DelendumInstructionSelector::selectConst(const APInt &Imm,
                                              MachineInstr &I) const {
  // NO-OP
  return true;
}

bool DelendumInstructionSelector::selectFrameIndex(MachineInstr &I) const {
  // NO-OP
  return true;
}

// TODO: Should we be using a (pre/post-legalizer?) pass so we don't have to fold
// G_STORE, G_LOAD, and G_ADD/G_SUB/G_MUL/...?
// We also shouldn't be explicitly passing in the destination offset.
bool DelendumInstructionSelector::selectArithmetic(MachineInstr &I,
                                                  int DstOffset) const {
  MachineInstr *MI = nullptr;
  using namespace TargetOpcode;

  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  const llvm::TargetSubtargetInfo &STI = MF.getSubtarget();
  unsigned StackAlignment = STI.getFrameLowering()->getStackAlignment();

  MachineInstr *Src0 = MRI.getVRegDef(I.getOperand(1).getReg());
  MachineInstr *Src1 = MRI.getVRegDef(I.getOperand(2).getReg());

  if (Src0->getOpcode() != G_LOAD) {
    llvm_unreachable("Immediate value not supported for this operand");
  } else if (Src1->getOpcode() == G_CONSTANT) {
    MachineInstr *Load0 = MRI.getVRegDef(Src0->getOperand(1).getReg());
    int SrcOffset0 = Load0->getOperand(1).getIndex() * StackAlignment; 
    APInt Value1 = Src1->getOperand(1).getCImm()->getValue();
    int OpCode = I.getOpcode() == G_ADD ? DL::ADDi : DL::SUBi;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(OpCode))
             .addImm(DstOffset)
             .addImm(SrcOffset0)
             .addImm(Value1.getSExtValue());
  } else {
    MachineInstr *Load0 = MRI.getVRegDef(Src0->getOperand(1).getReg());
    MachineInstr *Load1 = MRI.getVRegDef(Src1->getOperand(1).getReg());
    int SrcOffset0 = getOffsetFP(Load0->getOperand(1));
    int SrcOffset1 = getOffsetFP(Load1->getOperand(1));

    int OpCode;
    if (I.getOpcode() == G_ADD) {
      OpCode = DL::ADD;
    } else if (I.getOpcode() == G_SUB) {
      OpCode = DL::SUB;
    } else if (I.getOpcode() == G_MUL) {
      OpCode = DL::MUL;
    } else {
      llvm_unreachable("Unsupported opcode");
    }

    // Detect if the output of this instruction is a return value,
    // and if so, store in fp - 4

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(OpCode))
             .addImm(DstOffset)
             .addImm(SrcOffset0)
             .addImm(SrcOffset1);
  }

  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool DelendumInstructionSelector::selectStore(MachineInstr &I) const {
  MachineInstr *MI = nullptr;
  using namespace TargetOpcode;

  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  MachineInstr *Src0 = MRI.getVRegDef(I.getOperand(0).getReg());
  MachineInstr *Src1 = MRI.getVRegDef(I.getOperand(1).getReg());
  if (Src1->getOpcode() == G_FRAME_INDEX) {
    int SrcOffset1 = getOffsetFP(Src1->getOperand(1));

    if (Src0->getOpcode() == G_CONSTANT) {
      APInt ConstantValue = Src0->getOperand(1).getCImm()->getValue();
      std::array<unsigned, 4> ConstantBytes;
      for (unsigned I = 0; I < 4; ++I) {
        ConstantBytes[I] = static_cast<unsigned>(
                (ConstantValue.ashr(I * 8)).getZExtValue() & 0xFF);
      }

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(DL::SET32))
               .addImm(SrcOffset1)
               .addImm(ConstantBytes[3])
               .addImm(ConstantBytes[2])
               .addImm(ConstantBytes[1])
               .addImm(ConstantBytes[0]);
      return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);

    } else {
      MachineInstr *I2 = MRI.getVRegDef(I.getOperand(0).getReg());
      if (I2->getOpcode() == G_ADD || I2->getOpcode() == G_SUB || 
          I2->getOpcode() == G_MUL) {
        selectArithmetic(*I2, SrcOffset1);
        return true;
      }
    }
      
  }
}

namespace llvm {
InstructionSelector *
createDelendumInstructionSelector(const DelendumTargetMachine &TM,
                                  const DelendumSubtarget &Subtarget,
                                  const DelendumRegisterBankInfo &RBI) {
  return new DelendumInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
