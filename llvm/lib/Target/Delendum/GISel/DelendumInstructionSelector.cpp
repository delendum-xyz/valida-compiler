//===-- DelendumInstructionSelector.cpp -------------------------*- C++ -*-===//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// Delendum.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include <array>
#include <cstdint>

#include "DelendumRegisterBankInfo.h"
#include "DelendumSubtarget.h"
#include "DelendumTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/Support/Debug.h"

#define DEBUG_TYPE "delendum-isel"

using namespace llvm;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

namespace {

class DelendumInstructionSelector : public InstructionSelector {
public:
  DelendumInstructionSelector(const DelendumTargetMachine &TM, 
                              const DelendumSubtarget &STI,
                              const DelendumRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  static const char *getName() { return DEBUG_TYPE; }

  // Custom instruction selection that didn't occur in TableGen
  bool customSelect(MachineInstr &I) const;
  bool selectFrameIndex(MachineInstr &I) const;
  bool selectJump(MachineInstr &I) const;
  bool selectCall(MachineInstr &I) const;
  bool selectArithmetic(MachineInstr &I, int Offset) const;
  bool selectStore(MachineInstr &I) const;

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  int getFPOffset(MachineOperand &MI) const;

  const DelendumTargetMachine &TM;
  const DelendumInstrInfo &TII;
  const DelendumRegisterInfo &TRI;
  const DelendumRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

DelendumInstructionSelector::DelendumInstructionSelector(
    const DelendumTargetMachine &TM, const DelendumSubtarget &STI,
    const DelendumRegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "DelendumGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

int DelendumInstructionSelector::getFPOffset(MachineOperand &MO) const {
  MachineInstr &I = *MO.getParent();
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineFrameInfo &MFI = MF.getFrameInfo();

  // Offset is relative to frame pointer
  int Index = MO.getIndex();
  int Offset = MFI.getObjectOffset(Index); 
  return Offset;
}

bool DelendumInstructionSelector::select(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");

  if (customSelect(I)) {
    I.removeFromParent();
    return true;
  }

  // Certain non-generic instructions also need some special handling.
  if (!isPreISelGenericOpcode(I.getOpcode()))
    return true;

  if (selectImpl(I, *CoverageInfo))
    return true;

  return false;
}

bool DelendumInstructionSelector::customSelect(MachineInstr &I) const {
  const unsigned Opcode = I.getOpcode();

  switch (Opcode) {
  case TargetOpcode::G_STORE:
    return selectStore(I);
  case TargetOpcode::G_BRCOND:
  case TargetOpcode::G_BR:
    return selectJump(I);
  case TargetOpcode::G_CONSTANT:
  case TargetOpcode::G_FRAME_INDEX:
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_ICMP:
    return true;
  case DL::CALL: {
    return selectCall(I);
  }
  default:
    return false;
  }
}

bool DelendumInstructionSelector::selectCall(MachineInstr &I) const {
  MachineBasicBlock &MBB = *I.getParent();
  const MachineOperand &PCAddr = I.getOperand(1);
  const MachineOperand &FPOffset = I.getOperand(2);

  MachineInstr *Imm32 = BuildMI(MBB, I, I.getDebugLoc(), TII.get(DL::IMM32))
                          .addImm(FPOffset.getImm()+8)
                          .addImm(0)
                          .addImm(0)
                          .addImm(0)
                          .addImm(-FPOffset.getImm());
  if (!constrainSelectedInstRegOperands(*Imm32, TII, TRI, RBI))
    return false;

  MachineInstr *Store = BuildMI(MBB, I, I.getDebugLoc(), TII.get(DL::JAL))
                          .add(FPOffset)
                          .add(PCAddr) 
                          .add(FPOffset);
  if (!constrainSelectedInstRegOperands(*Store, TII, TRI, RBI))
    return false;

  return true;
}

bool DelendumInstructionSelector::selectJump(MachineInstr &I) const {
  MachineInstr *MI = nullptr;

  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  const unsigned Opcode = I.getOpcode();

  if (Opcode == TargetOpcode::G_BR) {
    const MachineOperand &MO = I.getOperand(0);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(DL::BEQ))
        .add(MO)
        .addImm(0)
        .addImm(0);
  } else if (Opcode == TargetOpcode::G_BRCOND) {
    const MachineOperand &MO = I.getOperand(1);
    MachineInstr *Src0 = MRI.getVRegDef(I.getOperand(0).getReg());

    if (Src0->getOpcode() == TargetOpcode::G_ICMP) {
      CmpInst::Predicate Cond =
          static_cast<CmpInst::Predicate>(Src0->getOperand(1).getPredicate());
      switch (Cond) {
      case CmpInst::ICMP_NE: {
        MachineInstr *Load0 = MRI.getVRegDef(Src0->getOperand(2).getReg());
        MachineInstr *Load1 = MRI.getVRegDef(Src0->getOperand(3).getReg());
        MachineInstr *FrameIndex0 = MRI.getVRegDef(Load0->getOperand(1).getReg());
        MachineInstr *FrameIndex1 = MRI.getVRegDef(Load1->getOperand(1).getReg());
        int SrcOffset0 = getFPOffset(FrameIndex0->getOperand(1));
        int SrcOffset1 = getFPOffset(FrameIndex1->getOperand(1));

        MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(DL::BNE))
            .add(MO)
            .addImm(SrcOffset0)
            .addImm(SrcOffset1);
        break;
      }
      default:
        return false;
      }
    } else {
      llvm_unreachable("Unsupported opcode");
    }
  }

  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool DelendumInstructionSelector::selectArithmetic(MachineInstr &I,
                                                  int DstOffset) const {
  MachineInstr *MI = nullptr;
  using namespace TargetOpcode;

  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  const llvm::TargetSubtargetInfo &STI = MF.getSubtarget();
  unsigned StackAlignment = STI.getFrameLowering()->getStackAlignment();

  MachineInstr *Src0 = MRI.getVRegDef(I.getOperand(1).getReg());
  MachineInstr *Src1 = MRI.getVRegDef(I.getOperand(2).getReg());

  if (Src0->getOpcode() != G_LOAD) {
    llvm_unreachable("Immediate value not supported for this operand");
  } else if (Src1->getOpcode() == G_CONSTANT) {
    MachineInstr *Load0 = MRI.getVRegDef(Src0->getOperand(1).getReg());
    int SrcOffset0 = getFPOffset(Load0->getOperand(1));
    APInt Value1 = Src1->getOperand(1).getCImm()->getValue();
    int OpCode = I.getOpcode() == G_ADD ? DL::ADDi : DL::SUBi;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(OpCode))
             .addImm(DstOffset)
             .addImm(SrcOffset0)
             .addImm(Value1.getSExtValue());
  } else {
    MachineInstr *Load0 = MRI.getVRegDef(Src0->getOperand(1).getReg());
    MachineInstr *Load1 = MRI.getVRegDef(Src1->getOperand(1).getReg());
    int SrcOffset0 = getFPOffset(Load0->getOperand(1));
    int SrcOffset1 = getFPOffset(Load1->getOperand(1));

    int OpCode;
    if (I.getOpcode() == G_ADD) {
      OpCode = DL::ADD;
    } else if (I.getOpcode() == G_SUB) {
      OpCode = DL::SUB;
    } else if (I.getOpcode() == G_MUL) {
      OpCode = DL::MUL;
    } else {
      llvm_unreachable("Unsupported opcode");
    }

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(OpCode))
             .addImm(DstOffset)
             .addImm(SrcOffset0)
             .addImm(SrcOffset1);
  }

  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool DelendumInstructionSelector::selectStore(MachineInstr &I) const {
  MachineInstr *MI = nullptr;
  using namespace TargetOpcode;

  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  MachineInstr *Src0 = MRI.getVRegDef(I.getOperand(0).getReg());
  MachineInstr *Src1 = MRI.getVRegDef(I.getOperand(1).getReg());

  if (Src1->getOpcode() != G_FRAME_INDEX) {
    llvm_unreachable("Unsupported opcode");
  }

  int SrcOffset1 = getFPOffset(Src1->getOperand(1));

  switch (Src0->getOpcode()) {
    case G_CONSTANT: {
      APInt ConstantValue = Src0->getOperand(1).getCImm()->getValue();
      std::array<unsigned, 4> ConstantBytes;
      for (unsigned I = 0; I < 4; ++I) {
        ConstantBytes[I] = static_cast<unsigned>(
                (ConstantValue.ashr(I * 8)).getZExtValue() & 0xFF);
      }
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(DL::IMM32))
               .addImm(SrcOffset1)
               .addImm(ConstantBytes[3])
               .addImm(ConstantBytes[2])
               .addImm(ConstantBytes[1])
               .addImm(ConstantBytes[0]);
      break;
    }
    case DL::CALL: {
      int DstOffset = getFPOffset(Src1->getOperand(1));
      int JmpOffset = Src0->getOperand(0).getImm();
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(DL::STORE32))
               .addImm(DstOffset)
               .addImm(JmpOffset);
      break;
    }
    case G_LOAD: {
      MachineInstr *FI0 = MRI.getVRegDef(Src0->getOperand(1).getReg());
      int SrcOffset = getFPOffset(FI0->getOperand(1));
      int DstOffset = getFPOffset(Src1->getOperand(1));
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(DL::STORE32))
               .addImm(DstOffset)
               .addImm(SrcOffset);
      break;
    }
    case G_ADD:
    case G_SUB:
    case G_MUL: {
      selectArithmetic(*Src0, SrcOffset1);
      return true;
    }
    default:
      llvm_unreachable("Unsupported opcode");
  }

  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

namespace llvm {
InstructionSelector *
createDelendumInstructionSelector(const DelendumTargetMachine &TM,
                                  const DelendumSubtarget &Subtarget,
                                  const DelendumRegisterBankInfo &RBI) {
  return new DelendumInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
